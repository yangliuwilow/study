# JVM内存结构和垃圾回收过程分析 

## 一、**Java中的内存分配：**

Java程序在运行时，需要在内存中的分配空间。为了提高运算效率，就对数据进行了不同空间的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。

具体划分为如下5个内存空间：（非常重要）

- 栈：存放局部变量

- 堆：存放所有new出来的东西
- 方法区：被虚拟机加载的类信息、常量、静态常量等。
- 程序计数器(和系统相关)
- 本地方法栈




![1530088635097](..\images\jvm.jpg)

### 1、**虚拟机栈：**

  　　1. 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等)
  　　2. JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等)
  　　3. 栈属于线程私有，不能实现线程间的共享!
  　　4. 栈的存储特性是“先进后出，后进先出”
  　　5. 栈是由系统自动分配，速度快!栈是一个连续的内存空间!
  　　6. 每一个方法对应一个栈帧，方法的参数，局部变量都放在栈帧
  　　7. 每一个线程都拥有一个栈空间，在线程中调用一个方法的时候就会启动一个栈帧，每一个栈帧中保存这个方法用到的局部变量。

### 2、**堆：**

　　1. 堆用于存储创建好的对象和数组(数组也是对象)

　　2. JVM只有一个堆，被所有线程共享

　　3. 堆是一个不连续的内存空间，分配灵活，速度慢!

### 3、**方法区：**

　　1. JVM只有一个方法区，被所有线程共享!

　　2. 方法区实际也是堆，只是用于存储类、常量相关的信息!

　　3. 用来存放程序中永远是不变或唯一的内容。(存储类信息【Class对象】、静态变量、静态方法、字符串常量等)



### 4、本地方法栈 ： 

​              线程私有。本地方法栈和虚拟机栈所发挥的作用非常相似，它们之间的区别主要是，虚拟机栈是为虚拟机执行Java方法（也就是字节码）服务的，而本地方法栈则为虚拟机使用到的Native方法服务。与虚拟机栈类似，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。 

### 5、**程序计数器** ：

​           线程私有，记录当前线程执行的位置。程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。 



## 二、**在JVM中共享数据空间划分如下图所示** ：

![908514-20160728195713028-1922699910](..\images\908514-20160728195713028-1922699910.jpg)

### **1、JVM中堆内存空间分配:**（共享空间）

​         **新生代（Young Generation）**： 

​                  新生代可以划分为三个区,Eden区（存放新生对象），

​                  两个幸存区（From Survivor和To Survivor）（存放每次垃圾回收后存活的对象）

​         **老年代（Old Generation）**：经过多次GC后，对象没有被回收进入和new大对象直接放**老年代**， 

​         **永久代（Permanent Generation）**:存储类信息【Class对象】、静态变量、静态方法、字符串常量等)

Eden：From Survivor:To Survivor=8:1:1

jvm内存比例设置：新生代:老年代=1:3 或者1:2

 

**引用类型：强、软、弱、虚、**

**如何确定垃圾：**

- 引用计数：

- 正向可达（当前确定垃圾的算法）：

  从roots对象计算可以到达的对象

###  2、**垃圾回收过程** 

​       1、新创建的对象，绝大多数都会存储在Eden中，

​       2、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（Minor GC），将无用对象清理掉，

​           然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区

​       3、当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，

​          同时将Eden区中的不能清空的对象，也复制到S2中，保证Eden和S1，均被清空。

​       4、重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中，则触发垃圾回收（Major GC）

​       5、当Old区满了，则会触发一个一次完整地垃圾回收（FullGC）， 

### 3、GC类型

- ​       Minor GC:

　　用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空)

- 　　Major GC：

　　用于清理年轻代区域。

- 　　Full GC：

　　用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。
  ### 3、垃圾回收算法
  1、引用计数法
     优点：
     缺点：每次对象赋值都需要维护引用计算器，其计算器本身需要消耗；较难处理循环引用；
  2、复制拷贝法   （年轻代minor GC）
      优点：效率高，没有碎片
      缺点：需要双倍空间，
  3、标记清除法   （老年代 Full GC）  标记幸存者，清除没有标记的
      优点：不需要额外的空间
      缺点: 扫描2次，标记一次，清除一次，有空间碎片
  4、标记压缩法    （老年代 Full GC）  ，先标记在压缩 
      优点：没有内存碎片
      缺点: 扫描2次，标记一次，压缩一次，有对象移动的成本
  5、标记清除压缩法  ，先标记在清除，清除多次后，再压缩
      优点：减少了移动对象的成本
      缺点: 扫描2次，标记一次，压缩一次，有对象移动的成本


## 三、java创建过程内存分配说明：

### 1、创建java类

~~~java
class Computer {
    String brand;  //品牌
}
public class SxtStu {
    // field
    int id;
    String sname;
    int age;
    Computer comp;
    void study() {
        System.out.println("我正在学习！使用我们的电脑，"+comp.brand);
    }
    SxtStu() {
    }
    public static void main(String[] args) {
        SxtStu stu1 = new SxtStu();
        stu1.sname = "张三";
        Computer comp1 = new Computer();
        comp1.brand = "联想";
        stu1.comp = comp1;
        stu1.study();
    }
}
~~~

### 2、main方法执行创建过程如图：

   ![908514-20160728195713028-1922699910](..\images\jvm-1.png)

![908514-20160728195713028-1922699910](..\images\jvm-2.png)

参考：http://www.sxt.cn/Java_jQuery_in_action/object-oriented.html

参考：https://blog.csdn.net/fuzhongmin05/article/details/78169044
