### 一、java内存结构

![1530088635097](images\1530088635097.png)



 

**虚拟机栈**： 每一个方法对应一个栈帧，方法的参数，局部变量都放在栈帧

​                   每一个线程都拥有一个栈空间，在线程中调用一个方法的时候就会启动一个栈帧，没一个栈帧中保存这个方法用到的局部变量。

**堆**：所有new出来的都放在  heap里面

**方法区（永久区）：**   perm开头

​       class文件信息，静态变量，字符串常量，常量池 这类放在 永久区；

**在JVM中共享数据空间划分如下图所示** 

![908514-20160728195713028-1922699910](images\908514-20160728195713028-1922699910.jpg)

 



1.JVM中共享数据空间可以分成三个大区，新生代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation），其中JVM堆分为新生代和老年代

2.新生代可以划分为三个区，Eden区（存放新生对象），两个幸存区（From Survivor和To Survivor）（存放每次垃圾回收后存活的对象）

3.永久代管理class文件、静态对象、属性等 

Eden：From Survivor:To Survivor=8:1:1

新生代:老年代=1:3 或者1:2

**回收的过程:**

新建对象在Eden区，进行一次GC后有，有引用的对象复制到Survivor区，没引用的对象被回收。

经过多次GC后，对象没有被回收进入  **老年代**

创建的大对象直接放**老年代**

**引用类型：强、软、弱、虚、**

**如何确定垃圾：**

-   引用计数：

-   正向可达（当前确定垃圾的算法）：

    从roots对象计算可以到达的对象



**垃圾收集算法**：

​     **标记清除**（mark-sweep）:缺点 不连续，内存碎片化

​     **拷贝 coping** （Survivor区使用这个算法） ：把内存分为2部分，A区满后拷贝到B区，B区满后存活对象拷贝A区，缺点：服务器内存浪费； 

​     **标记压缩(**mark-compact老年代使用这个算法)：按顺序拷贝存放，可用和不可用的内存

### 二、JVM参数

**- **       标准参数，所有jVM都应该支持

-X      非标准，每个jvm实现都不同

-XX   不稳定参数，下一个版本可能会取消







